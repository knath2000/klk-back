// Stream response with timeout wrapper
const streamPromise = (async () => {
  const stream = openRouterAdapter.streamCompletion(messages, options);
  let fullContent = '';
  const assistantMessageId = this.generateMessageId();

  try {
    for await (const chunk of stream) {
      if (chunk.deltaText) {
        fullContent += chunk.deltaText;
        socket.emit('assistant_delta', {
          message_id: assistantMessageId,
          chunk: chunk.deltaText,
          index: fullContent.length,
          total: null // Unknown total for streaming
        });
      }
    }
    return { fullContent, assistantMessageId };
  } catch (streamError) {
    console.error('[OpenRouter] Stream error:', streamError);
    socket.emit('llm_error', { message: 'LLM stream failed: ' + (streamError as Error).message });
    throw streamError;
  }
})();

let finalContent = '';
let finalAssistantMessageId = '';

try {
  const { fullContent, assistantMessageId } = await Promise.race([
    streamPromise,
    new Promise<never>((_, reject) => setTimeout(() => reject(new Error('Stream timeout')), 60000)) // Overall 60s timeout
  ]);

  console.log('[DEBUG] OpenRouter call completed');
  console.log('[OpenRouter] streamCompletion completed, full content length:', fullContent.length);

  // Check if streaming returned zero content, fallback to non-stream
  if (fullContent.length === 0) {
    console.log('[OpenRouter] No streamed chunks; invoking non-stream fallback');
    const fallbackContent = await openRouterAdapter.fetchCompletion(messages, options);
    if (fallbackContent.trim().length > 0) {
      finalContent = fallbackContent;
      finalAssistantMessageId = assistantMessageId;
    } else {
      socket.emit('llm_error', { message: 'No response generated from LLM' });
      return;
    }
  } else {
    finalContent = fullContent;
    finalAssistantMessageId = assistantMessageId;
  }
} catch (streamError) {
  console.error('[OpenRouter] Stream failed, attempting non-stream fallback:', streamError.message);
  try {
    const fallbackContent = await openRouterAdapter.fetchCompletion(messages, options);
    if (fallbackContent.trim().length > 0) {
      finalContent = fallbackContent;
      finalAssistantMessageId = this.generateMessageId();
    } else {
      socket.emit('llm_error', { message: 'No response generated from LLM after fallback' });
      return;
    }
  } catch (fallbackError) {
    console.error('[OpenRouter] Fallback also failed:', fallbackError);
    socket.emit('llm_error', { message: 'LLM completely failed: ' + (fallbackError as Error).message });
    return;
  }
}
